#!/usr/bin/env python

import sys, os

input_file = ""

type_translation = {
#	C type				(ASM type, size)
	'int32_t':				('dd', 4),
	'uint32_t':				('dd', 4),
	'atomic_int32_t':		('dd', 4),
	'uint64_t': 			('dq', 8),
	'size_t':				('dq', 8),
	'multiboot_info_t*':	('dq', 8)
}


def parse_line(line, number):
	global type_translation

    # ignore empty lines
	if not line:
		return

    # ignore comments
	if line.startswith('//'):
		return

	try:
		# parse into variables
		splitted = line.split()
		c_type = 	splitted[0]
		c_name = 	splitted[1]
		c_value = 	splitted[3]
	except:
		print('Line {}: badly formatted'.format(number))
		sys.exit(1)

	# remove ; from value if present
	if c_value[-1] == ';':
		c_value = c_value[0:-1]


	comment = ''
	if len(splitted) > 5:
		comment = ' '.join(splitted[5:])
		if splitted[4] != '//':
			print("Line {}: unhandled characters after value: '{}'".format(
				number, comment))
			sys.exit(1)

	if not c_type in type_translation:
		print("Line {}: unkown type '{}'".format(number, c_type))
		sys.exit(1)

	return {
		'type': c_type,
		'name': c_name,
		'value': c_value,
		'comment': comment,
		}


def export_c_header(arguments, filename):
	global type_translation, input_file

	with open(filename, 'w') as f:
		f.write('// DO NOT EDIT THIS FILE, because it has been automatically\n')
		f.write('// generated from {}!\n\n'.format(
			os.path.basename(input_file)))

		# add include guard
		f.write('#ifndef ARCH_X86_INCLUDE_ASM_KERNEL_ARGUMENTS\n')
		f.write('#define ARCH_X86_INCLUDE_ASM_KERNEL_ARGUMENTS\n')
		f.write('\n')
		f.write('#include <asm/stddef.h>\n')
		f.write('#include <asm/atomic32.h>\n')
		f.write('#include <asm/multiboot.h>\n')
		f.write('\n')
		f.write('typedef struct __attribute__(( packed )) hermit_kernel_arguments {\n')

		# align name column by equalizing type width
		type_lengths = [len(arg['type']) for arg in arguments]
		member_fmt = '\t{type:' + str(max(type_lengths)) + 's} {name};\n'

		offset = 0
		for argument in arguments:
			if argument['comment']:
				f.write('\t/// {}\n'.format(argument['comment']))

			f.write(member_fmt.format(
				**argument,
				offset = offset))

			offset += type_translation[argument['type']][1]

		f.write('} hermit_kernel_arguments_t;\n')
		f.write('\n')
		f.write('extern hermit_kernel_arguments_t kernel_arguments;\n')
		f.write('\n')
		f.write('#endif // ARCH_X86_INCLUDE_ASM_KERNEL_ARGUMENTS\n')


def export_asm_def(arguments, filename):
	global type_translation, input_file

	with open(filename, 'w') as f:
		f.write('; DO NOT EDIT THIS FILE, because it has been automatically\n')
		f.write('; generated from {}!\n\n'.format(
			os.path.basename(input_file)))

		# align name comments by equalizing name width
		name_lengths = [len(arg['name']) for arg in arguments]
		export_fmt = 'global {name:' + str(max(name_lengths)) + 's}\t; offset 0x{offset:02x}\n'

		f.write('; Exporting global symbols\n')
		offset = 0
		for argument in arguments:
			f.write(export_fmt.format(
				name = argument['name'],
				offset = offset))
			offset += type_translation[argument['type']][1]

		f.write('\n; Define arguments\n')
		f.write('align 4\n')
		f.write('global kernel_arguments\n')
		f.write('kernel_arguments:\n')
		for argument in arguments:
			f.write("{name} {type} {value}\n".format(
				name = argument['name'],
				type = type_translation[argument['type']][0],
				value = argument['value']))

def print_usage():
	print("Usage: {} INPUT_FILE OUT_ASM OUT_C".format(
		os.path.basename(sys.argv[0])))

if __name__ == '__main__':
	try:
		input_file = sys.argv[1]
	except:
		print("No input file given\n")
		print_usage()
		sys.exit(1)

	if not os.path.isfile(input_file):
		print("No such file: {}".format(input_file))
		sys.exit(1)

	try:
		output_asm = sys.argv[2]
		output_c = sys.argv[3]
	except:
		print('Not enough arguments\n')
		print_usage()
		sys.exit()

	output_dir_asm = os.path.dirname(output_asm)
	output_dir_c = os.path.dirname(output_c)

	if not os.path.isdir(output_dir_c):
		print("No such directory: {}".format(output_dir_c))
		sys.exit(1)

	if not os.path.isdir(output_dir_asm):
		print("No such directory: {}".format(output_dir_asm))
		sys.exit(1)

	with open(input_file, 'r') as f:
		arguments = []

		# parse input file
		for line_number, line in enumerate(f.readlines()):
			arg = parse_line(line.strip(), line_number + 1)
			if arg:
				arguments.append(arg)

		# export to C header and NASM definitions
		export_asm_def(arguments, output_asm)
		export_c_header(arguments, output_c)
